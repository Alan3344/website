"use strict";(self.webpackChunkflet_dev=self.webpackChunkflet_dev||[]).push([[5921],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return h}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var i=n.createContext({}),p=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(i.Provider,{value:t},e.children)},c="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,o=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(a),u=l,h=c["".concat(i,".").concat(u)]||c[u]||f[u]||o;return a?n.createElement(h,r(r({ref:t},d),{},{components:a})):n.createElement(h,r({ref:t},d))}));function h(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var o=a.length,r=new Array(o);r[0]=u;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[c]="string"==typeof e?e:l,r[1]=s;for(var p=2;p<o;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},3474:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return i},default:function(){return u},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return c}});var n=a(7462),l=a(3366),o=(a(7294),a(3905)),r=["components"],s={title:"Creating Solitaire game with Python and Flet - Part 1",sidebar_label:"Python - Solitaire game",slug:"python-solitaire"},i=void 0,p={unversionedId:"tutorials/python-solitaire",id:"tutorials/python-solitaire",title:"Creating Solitaire game with Python and Flet - Part 1",description:"In this tutorial we will show you step-by-step creation of a famous Klondike solitaire game in Python with Flet. For an inspiration, we looked at this online game//www.solitr.com/",source:"@site/docs/tutorials/python-solitaire.md",sourceDirName:"tutorials",slug:"/tutorials/python-solitaire",permalink:"/docs/tutorials/python-solitaire",draft:!1,editUrl:"https://github.com/flet-dev/website/edit/main/docs/tutorials/python-solitaire.md",tags:[],version:"current",frontMatter:{title:"Creating Solitaire game with Python and Flet - Part 1",sidebar_label:"Python - Solitaire game",slug:"python-solitaire"},sidebar:"docs",previous:{title:"Python - Trello clone",permalink:"/docs/tutorials/trello-clone"},next:{title:"Python - Realtime Chat app",permalink:"/docs/tutorials/python-realtime-chat"}},d={},c=[{value:"Getting started with Flet",id:"getting-started-with-flet",level:2},{value:"Proof of concept app for draggable cards",id:"proof-of-concept-app-for-draggable-cards",level:2},{value:"Step 1: Drag the card around",id:"step-1-drag-the-card-around",level:3},{value:"Step 2: Drop the card in the slot or bounce it back",id:"step-2-drop-the-card-in-the-slot-or-bounce-it-back",level:3},{value:"Step 3: Adding a second card",id:"step-3-adding-a-second-card",level:3},{value:"Step 4: Adding more slots",id:"step-4-adding-more-slots",level:3},{value:"Fanned card piles",id:"fanned-card-piles",level:2},{value:"Slot, Card and Solitaire classes",id:"slot-card-and-solitaire-classes",level:3},{value:"Placing card with offset",id:"placing-card-with-offset",level:3},{value:"Drag pile of cards",id:"drag-pile-of-cards",level:3},{value:"Solitaire setup",id:"solitaire-setup",level:2},{value:"Create card deck",id:"create-card-deck",level:3},{value:"Create slots",id:"create-slots",level:3},{value:"Deal cards",id:"deal-cards",level:3},{value:"Reveal top cards in tableau piles",id:"reveal-top-cards-in-tableau-piles",level:3},{value:"Solitaire rules",id:"solitaire-rules",level:2},{value:"General rules",id:"general-rules",level:3},{value:"Foundations rules",id:"foundations-rules",level:3},{value:"Tableau rules",id:"tableau-rules",level:3},{value:"Stock and waste",id:"stock-and-waste",level:3},{value:"Winning the game",id:"winning-the-game",level:2},{value:"Deploying the app",id:"deploying-the-app",level:2},{value:"Summary",id:"summary",level:2}],f={toc:c};function u(e){var t=e.components,a=(0,l.Z)(e,r);return(0,o.kt)("wrapper",(0,n.Z)({},f,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In this tutorial we will show you step-by-step creation of a famous Klondike solitaire game in Python with Flet. For an inspiration, we looked at this online game: ",(0,o.kt)("a",{parentName:"p",href:"https://www.solitr.com/"},"https://www.solitr.com/")),(0,o.kt)("p",null,"This tutorial is aimed at beginner/intermediate level Python developers who have basic knowledge of Python and object oriented programming."),(0,o.kt)("p",null,"Here you can see the final result that you are going to achieve with Flet and this tutorial:\n",(0,o.kt)("a",{parentName:"p",href:"https://gallery.flet.dev/solitaire/"},"https://gallery.flet.dev/solitaire/")),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/part1_final.gif",className:"screenshot-50"}),(0,o.kt)("p",null,"We have broken down the game implementation into the following steps:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#getting-started-with-flet"},"Getting started with Flet")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#proof-of-concept-app-for-draggable-cards"},"Proof of concept app for draggable cards")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#fanned-card-piles"},"Fanned card piles")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#solitaire-setup"},"Solitaire setup")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#solitaire-rules"},"Solitaire rules")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#winning-the-game"},"Winning the game")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#deploying-the-app"},"Deploying the app"))),(0,o.kt)("p",null,"In the Part 2 (will be covered in the next tutorial) we'll be adding Appbar with options to start new game, view game rules and change game settings."),(0,o.kt)("h2",{id:"getting-started-with-flet"},"Getting started with Flet"),(0,o.kt)("p",null,"To create a Flet web app you don't need to know HTML, CSS or JavaScript, but you do need a basic knowledge of Python and object-oriented programming."),(0,o.kt)("p",null,"Flet requires Python 3.7 or above. To create a web app in Python with Flet, you need to install ",(0,o.kt)("inlineCode",{parentName:"p"},"flet")," module first:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"pip install flet\n")),(0,o.kt)("p",null,"To start, let's create a simple hello-world app."),(0,o.kt)("p",null,"Create ",(0,o.kt)("inlineCode",{parentName:"p"},"hello.py")," with the following contents:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import flet as ft\n\ndef main(page: ft.Page):\n    page.add(ft.Text(value="Hello, world!"))\n\nft.app(target=main)\n')),(0,o.kt)("p",null,"Run this app and you will see a new window with a greeting:"),(0,o.kt)("img",{src:"/img/docs/tutorial/todo-app-hello-world.png",className:"screenshot-40"}),(0,o.kt)("h2",{id:"proof-of-concept-app-for-draggable-cards"},"Proof of concept app for draggable cards"),(0,o.kt)("p",null,"For the proof of concept, we will only be using three types of controls:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/controls/stack"},"Stack")," - will be used as a parent control for absolute positioning of slots and cards"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/controls/gesturedetector"},"GestureDetector")," - the card that will be moved within the Stack"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/controls/container"},"Container")," - the slot where the card will be dropped. Also will be used as ",(0,o.kt)("inlineCode",{parentName:"li"},"content")," for the GestureDetector.")),(0,o.kt)("p",null,"We have broken down the proof of concept app into four easy steps, so that after each step you have a complete short program to run and test."),(0,o.kt)("h3",{id:"step-1-drag-the-card-around"},"Step 1: Drag the card around"),(0,o.kt)("p",null,"In this step we will create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Stack")," (Solitaire game field) and a ",(0,o.kt)("inlineCode",{parentName:"p"},"GestureDetector")," (Solitaire card). The card will then be added to the list of the Stack ",(0,o.kt)("inlineCode",{parentName:"p"},"controls"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"Top")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"left")," properties of the GestureDetector are used for absolute positioning of the card in the Stack."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"import flet as ft\n\ndef main(page: ft.Page):\n \n   card = ft.GestureDetector(\n       left=0,\n       top=0,\n       content=ft.Container(bgcolor=ft.colors.GREEN, width=70, height=100),\n   )   \n \n   page.add(ft.Stack(controls=[card], width=1000, height=500))\n \nft.app(target=main)\n")),(0,o.kt)("p",null,"Run the app to see the the card added to the stack:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/drag_and_drop1.png",className:"screenshot-50"}),(0,o.kt)("p",null,"To be able to move the card, we'll create a ",(0,o.kt)("inlineCode",{parentName:"p"},"drag")," method that will be called in ",(0,o.kt)("inlineCode",{parentName:"p"},"on_pan_update")," event of GestureDetector which happens every ",(0,o.kt)("inlineCode",{parentName:"p"},"drag_interval")," while the user drags the card with their mouse."),(0,o.kt)("p",null,"To show the card's movement, we\u2019ll be updating the card\u2019s ",(0,o.kt)("inlineCode",{parentName:"p"},"top")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"left")," properties in the ",(0,o.kt)("inlineCode",{parentName:"p"},"drag")," method each time the ",(0,o.kt)("inlineCode",{parentName:"p"},"on_pan_update")," event happens."),(0,o.kt)("p",null,"Below is the simplest code for dragging GestureDetector in Stack:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"import flet as ft\n \n# Use of GestureDetector for with on_pan_update event for dragging card\n# Absolute positioning of controls within stack\n \ndef main(page: ft.Page):\n \n   def drag(e: ft.DragUpdateEvent):\n       e.control.top = max(0, e.control.top + e.delta_y)\n       e.control.left = max(0, e.control.left + e.delta_x)\n       e.control.update()\n \n   card = ft.GestureDetector(\n       mouse_cursor=ft.MouseCursor.MOVE,\n       drag_interval=5,\n       on_pan_update=drag,\n       left=0,\n       top=0,\n       content=ft.Container(bgcolor=ft.colors.GREEN, width=70, height=100),\n   )   \n \n   page.add(ft.Stack(controls=[card], width=1000, height=500))\n \nft.app(target=main)\n")),(0,o.kt)("p",null,"Now you can see the card moving:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/drag_and_drop2.gif",className:"screenshot-50"}),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"After any properties of a control are updated, an ",(0,o.kt)("inlineCode",{parentName:"p"},"update()")," method of the control (or its parent control) should be called for the update to take effect.")),(0,o.kt)("h3",{id:"step-2-drop-the-card-in-the-slot-or-bounce-it-back"},"Step 2: Drop the card in the slot or bounce it back"),(0,o.kt)("p",null,"The goal of this step is to be able to drop a card into a slot if it is close enough and bounce it back if it\u2019s not."),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/drag_and_drop3.gif",className:"screenshot-50"}),(0,o.kt)("p",null,"Let\u2019s create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Container")," control that will represent a slot to which we\u2019ll be dropping the card:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"slot = ft.Container(\n    width=70, height=100, left=200, top=0, border=ft.border.all(1)\n    )\npage.add(ft.Stack(controls = [slot, card], width=1000, height=500))\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"on_pan_end")," event of the card is called when the card is dropped: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"card = ft.GestureDetector(\n    mouse_cursor=ft.MouseCursor.MOVE,\n    drag_interval=5,\n    on_pan_update=drag,\n    on_pan_end=drop,\n    left=0,\n    top=0,\n    content=ft.Container(bgcolor=ft.colors.GREEN, width=70, height=100),\n)\n")),(0,o.kt)("p",null,"On this event, we\u2019ll call ",(0,o.kt)("inlineCode",{parentName:"p"},"drop")," method to check if the card is close enough to the slot (let\u2019s say it\u2019s closer than 20px to the slot), and ",(0,o.kt)("inlineCode",{parentName:"p"},"place")," it there:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def drop(e: ft.DragEndEvent):\n    if (\n        abs(e.control.top - slot.top) < 20\n        and abs(e.control.left - slot.left) < 20\n    ):\n        place(e.control, slot)\n    e.control.update()\n\ndef place(card, slot):\n    """place card to the slot"""\n    card.top = slot.top\n    card.left = slot.left\n    page.update()\n')),(0,o.kt)("p",null,"Now, if the card is not close enough, we need to bounce it back to its original position. Unfortunately, we don\u2019t know the original position coordinates, since the card\u2019s ",(0,o.kt)("inlineCode",{parentName:"p"},"top")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"left")," properties were changed on ",(0,o.kt)("inlineCode",{parentName:"p"},"on_pan_update")," event."),(0,o.kt)("p",null,"To solve this problem, let\u2019s create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Solitaire")," class object to remember the original position of the card when ",(0,o.kt)("inlineCode",{parentName:"p"},"on_pan_start")," event of the card is called:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"class Solitaire:\n   def __init__(self):\n       self.start_top = 0\n       self.start_left = 0\n\nsolitaire = Solitaire()\n\ndef start_drag(e: ft.DragStartEvent):\n    solitaire.start_top = e.control.top\n    solitaire.start_left = e.control.left\n    e.control.update()\n")),(0,o.kt)("p",null,"Now let\u2019s update ",(0,o.kt)("inlineCode",{parentName:"p"},"on_pan_end")," event with the option to bounce card back:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def bounce_back(game, card):\n    """return card to its original position"""\n    card.top = game.start_top\n    card.left = game.start_left\n    page.update()\n\ndef drop(e: ft.DragEndEvent):\n    if (\n        abs(e.control.top - slot.top) < 20\n        and abs(e.control.left - slot.left) < 20\n    ):\n        place(e.control, slot)\n\n    else:\n        bounce_back(solitaire, e.control)\n\n    e.control.update()\n')),(0,o.kt)("p",null,"The full code for this step can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/flet-dev/examples/blob/main/python/tutorials/solitaire/solitaire-drag-and-drop/step2.py"},"here"),"."),(0,o.kt)("h3",{id:"step-3-adding-a-second-card"},"Step 3: Adding a second card"),(0,o.kt)("p",null,"Eventually, we\u2019ll need 52 cards to play the game. For our proof of concept, let\u2019s add a second card:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"\n   card2 = ft.GestureDetector(\n       mouse_cursor=ft.MouseCursor.MOVE,\n       drag_interval=5,\n       on_pan_start=start_drag,\n       on_pan_update=drag,\n       on_pan_end=drop,\n       left=100,\n       top=0,\n       content=ft.Container(bgcolor=ft.colors.YELLOW, width=70, height=100),\n   )\n\n   controls = [slot, card1, card2]\n   page.add(ft.Stack(controls=controls, width=1000, height=500))\n")),(0,o.kt)("p",null,"Now, if you run the app with the two cards, you will notice that when you move the cards around, the yellow card (card2) is moving as expected but the green the card (card1) is moving under the yellow card. "),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/drag_and_drop4.gif",className:"screenshot-50"}),(0,o.kt)("p",null,"It happens because card2 is added to the list of stack ",(0,o.kt)("inlineCode",{parentName:"p"},"controls")," after card1. To fix this problem, we need to move the draggable card to the top of the list of controls on ",(0,o.kt)("inlineCode",{parentName:"p"},"on_pan_start")," event:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def move_on_top(card, controls):\n    """Moves draggable card to the top of the stack"""\n    controls.remove(card)\n    controls.append(card)\n    page.update()\n\ndef start_drag(e: ft.DragStartEvent):\n    move_on_top(e.control, controls)\n    solitaire.start_top = e.control.top\n    solitaire.start_left = e.control.left\n')),(0,o.kt)("p",null,"Now the two cards can be dragged without issues:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/drag_and_drop5.gif",className:"screenshot-50"}),(0,o.kt)("p",null,"The full code for this step can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/flet-dev/examples/blob/main/python/tutorials/solitaire/solitaire-drag-and-drop/step3.py"},"here"),"."),(0,o.kt)("h3",{id:"step-4-adding-more-slots"},"Step 4: Adding more slots"),(0,o.kt)("p",null,"As a final step for the proof of concept app, let\u2019s create two more slots:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"slot0 = ft.Container(\n    width=70, height=100, left=0, top=0, border=ft.border.all(1)\n)\n\nslot1 = ft.Container(\n    width=70, height=100, left=200, top=0, border=ft.border.all(1)\n)\n\nslot2 = ft.Container(\n    width=70, height=100, left=300, top=0, border=ft.border.all(1)\n)\n\nslots = [slot0, slot1, slot2]\n")),(0,o.kt)("p",null,"When creating new cards, we\u2019ll will not specify their ",(0,o.kt)("inlineCode",{parentName:"p"},"top")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"left")," position now, but instead, will place them to the ",(0,o.kt)("inlineCode",{parentName:"p"},"slot0"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# deal cards\nplace(card1, slot0)\nplace(card2, slot0)\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"on_pan_end")," event, where we check if a card is close to a slot, we will now go through the list of slots to find where the card should be dropped:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def drop(e: ft.DragEndEvent):\n    for slot in slots:\n        if (\n            abs(e.control.top - slot.top) < 20\n        and abs(e.control.left - slot.left) < 20\n        ):\n            place(e.control, slot)\n            e.control.update()\n            return\n        \n    bounce_back(solitaire, e.control)\n    e.control.update()\n")),(0,o.kt)("p",null,"As a result, the two cards can be dragged between the three slots:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/drag_and_drop6.gif",className:"screenshot-50"}),(0,o.kt)("p",null,"The full code for this step can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/flet-dev/examples/blob/main/python/tutorials/solitaire/solitaire-drag-and-drop/step4.py"},"here"),"."),(0,o.kt)("p",null,"Congratulations on completing the proof of concept app for the Solitaire game! Now you can work with ",(0,o.kt)("inlineCode",{parentName:"p"},"GestureDetector")," to move cards inside ",(0,o.kt)("inlineCode",{parentName:"p"},"Stack")," and place them to certain ",(0,o.kt)("inlineCode",{parentName:"p"},"Containers"),", which is a great part of the game to begin with."),(0,o.kt)("h2",{id:"fanned-card-piles"},"Fanned card piles"),(0,o.kt)("p",null,"In the proof of concept app you have accomplished the task of dropping a card to a slot in proximity or bounce it back. If there is already a card in that slot, the new card is placed on top of it, covering it completely."),(0,o.kt)("p",null,"In the actual Solitaire game, if there is already a card in a tableau slot, you want to place the draggable card a bit lower, so that you can see the previous card too, and if there are two cards, even lower. Those are called \u201cfanned piles\u201d."),(0,o.kt)("p",null,"Then, we want to be able to pick a card from the fanned pile that is not the top card of the pile and drag the card together with all the cards below it:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/fanned_piles3.gif",className:"screenshot-50"}),(0,o.kt)("p",null,"To be able to do that, it would be useful to have the information about the pile of cards in the slot from which the card is dragged, as well as in the slot to which it is being dropped. Let\u2019s restructure our program and get it ready for the implementation of the fanned piles."),(0,o.kt)("h3",{id:"slot-card-and-solitaire-classes"},"Slot, Card and Solitaire classes"),(0,o.kt)("p",null,"A slot could have a ",(0,o.kt)("inlineCode",{parentName:"p"},"pile")," property that would hold a list of cards that were placed there. Now the slot is a ",(0,o.kt)("inlineCode",{parentName:"p"},"Container")," control object, and we can\u2019t add any new properties to it. Let\u2019s create a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," class that will inherit from ",(0,o.kt)("inlineCode",{parentName:"p"},"Container")," and add a ",(0,o.kt)("inlineCode",{parentName:"p"},"pile")," property to it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"SLOT_WIDTH = 70\nSLOT_HEIGHT = 100\n \nimport flet as ft\n \nclass Slot(ft.Container):\n   def __init__(self, top, left):\n       super().__init__()\n       self.pile=[]\n       self.width=SLOT_WIDTH\n       self.height=SLOT_HEIGHT\n       self.left=left\n       self.top=top\n       self.border=ft.border.all(1)\n")),(0,o.kt)("p",null,"Similarly to ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," class, let\u2019s create a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Card")," class with ",(0,o.kt)("inlineCode",{parentName:"p"},"slot")," property to remember in which slot it resides. It will inherit from ",(0,o.kt)("inlineCode",{parentName:"p"},"GestureDetector")," and we\u2019ll move all card-related methods to it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'CARD_WIDTH = 70\nCARD_HEIGTH = 100\nDROP_PROXIMITY = 20\n \nimport flet as ft\n \nclass Card(ft.GestureDetector):\n   def __init__(self, solitaire, color):\n       super().__init__()\n       self.slot = None\n       self.mouse_cursor=ft.MouseCursor.MOVE\n       self.drag_interval=5\n       self.on_pan_start=self.start_drag\n       self.on_pan_update=self.drag\n       self.on_pan_end=self.drop\n       self.left=None\n       self.top=None\n       self.solitaire = solitaire\n       self.color = color\n       self.content=ft.Container(bgcolor=self.color, width=CARD_WIDTH, height=CARD_HEIGTH)\n   \n   def move_on_top(self):\n       """Moves draggable card to the top of the stack"""\n       self.solitaire.controls.remove(self)\n       self.solitaire.controls.append(self)\n       self.solitaire.update()\n \n   def bounce_back(self):\n       """Returns card to its original position"""\n       self.top = self.slot.top\n       self.left = self.slot.left\n       self.update()\n \n   def place(self, slot):\n       """Place card to the slot"""\n       self.top = slot.top\n       self.left = slot.left\n \n   def start_drag(self, e: ft.DragStartEvent):\n       self.move_on_top()\n       self.update()\n \n   def drag(self, e: ft.DragUpdateEvent):\n       self.top = max(0, self.top + e.delta_y)\n       self.left = max(0, self.left + e.delta_x)\n       self.update()\n \n   def drop(self, e: ft.DragEndEvent):\n       for slot in self.solitaire.slots:\n           if (\n               abs(self.top - slot.top) < DROP_PROXIMITY\n           and abs(self.left - slot.left) < DROP_PROXIMITY\n         ):\n               self.place(slot)\n               self.update()\n               return\n         \n       self.bounce_back()\n       self.update()\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Note: since each card has ",(0,o.kt)("inlineCode",{parentName:"p"},"slot")," property now, there is no need to remember ",(0,o.kt)("inlineCode",{parentName:"p"},"start_left")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"start_top")," position of the draggable card in Solitaire class anymore, because we can just bounce it back to it\u2019s slot.")),(0,o.kt)("p",null,"Let\u2019s update ",(0,o.kt)("inlineCode",{parentName:"p"},"Solitaire")," class to inherit from ",(0,o.kt)("inlineCode",{parentName:"p"},"Stack"),", and move the creation of cards and slots there:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'SOLITAIRE_WIDTH = 1000\nSOLITAIRE_HEIGHT = 500\n \nimport flet as ft\nfrom slot import Slot\nfrom card import Card\n \nclass Solitaire(ft.Stack):\n   def __init__(self):\n       super().__init__()\n       self.controls = []\n       self.slots = []\n       self.cards = []\n       self.width = SOLITAIRE_WIDTH\n       self.height = SOLITAIRE_HEIGHT\n \n   def did_mount(self):\n       self.create_card_deck()\n       self.create_slots()\n       self.deal_cards()\n \n   def create_card_deck(self):\n       card1 = Card(self, color="GREEN")\n       card2 = Card(self, color="YELLOW")\n       self.cards = [card1, card2]\n \n   def create_slots(self):\n       self.slots.append(Slot(top=0, left=0))\n       self.slots.append(Slot(top=0, left=200))\n       self.slots.append(Slot(top=0, left=300))\n       self.controls.extend(self.slots)\n       self.update()\n \n   def deal_cards(self):\n       self.controls.extend(self.cards)\n       for card in self.cards:\n           card.place(self.slots[0])\n       self.update()\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"If you try to call ",(0,o.kt)("inlineCode",{parentName:"p"},"create_slots()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"create_card_deck()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"deal_cards()")," methods  ",(0,o.kt)("inlineCode",{parentName:"p"},"__init__()")," method of the Solitaire class, it will cause an error \u201cControl must be added to the page first\u201d. To fix this, we  create slots and cards inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"did_mount()")," method, which happens immediately after the stack is added to the page.")),(0,o.kt)("p",null,"Our main program will be very simple now:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"import flet as ft\nfrom solitaire import Solitaire\n \ndef main(page: ft.Page):\n  \n   solitaire = Solitaire()\n \n   page.add(solitaire)\n \nft.app(target=main)\n")),(0,o.kt)("p",null,"You can find the full source code for this step ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/flet-dev/examples/tree/main/python/tutorials/solitaire/solitaire-classes"},"here"),". It works exactly the same way as the proof of concept app, but re-written with the new classes to be ready for adding more complex functionality to it. "),(0,o.kt)("h3",{id:"placing-card-with-offset"},"Placing card with offset"),(0,o.kt)("p",null,"When the card is being placed to a slot in the ",(0,o.kt)("inlineCode",{parentName:"p"},"card.place()")," method, we need to do three things:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Remove the card from its original slot, if it exists"),(0,o.kt)("li",{parentName:"ul"},"Change card\u2019s slot to the new slot"),(0,o.kt)("li",{parentName:"ul"},"Add the card to the new slot\u2019s pile")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def place(self, slot):\n    # remove card from it's original slot, if exists\n    if self.slot is not None:\n        self.slot.pile.remove(self)\n    \n    # change card's slot to a new slot\n    self.slot = slot\n\n    # add card to the new slot's pile\n    slot.pile.append(self)\n")),(0,o.kt)("p",null,"When updating card\u2019s ",(0,o.kt)("inlineCode",{parentName:"p"},"top")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"left")," position, ",(0,o.kt)("inlineCode",{parentName:"p"},"left")," should remain the same, but ",(0,o.kt)("inlineCode",{parentName:"p"},"top")," will depend on the length of the new slot\u2019s pile:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"    self.top = slot.top + len(slot.pile) * CARD_OFFSET\n    self.left = slot.left\n")),(0,o.kt)("p",null,"Now the cards are placed with offset which gives us the fanned pile look:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/fanned_piles1.png",className:"screenshot-50"}),(0,o.kt)("h3",{id:"drag-pile-of-cards"},"Drag pile of cards"),(0,o.kt)("p",null,"If you try to drag the card from the bottom of the pile now, it will look like this:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/fanned_piles2.gif",className:"screenshot-50"}),(0,o.kt)("p",null,"To fix this problem, we need to update all the methods that work with the draggable card to work with the draggable pile instead."),(0,o.kt)("p",null,"Let\u2019s create ",(0,o.kt)("inlineCode",{parentName:"p"},"get_draggable_pile()")," method that will return list of cards that need to be dragged together, starting with the card you picked:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def get_draggable_pile(self):\n    """returns list of cards that will be dragged together, starting with the current card"""\n    if self.slot is not None:\n        return self.slot.pile[self.slot.pile.index(self):]\n    return [self]\n')),(0,o.kt)("p",null,"Then, we\u2019ll update ",(0,o.kt)("inlineCode",{parentName:"p"},"move_on_top()")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def move_on_top(self):\n    """Brings draggable card pile to the top of the stack"""\n    for card in draggable_pile:\n        self.solitaire.controls.remove(card)\n        self.solitaire.controls.append(card)\n    self.solitaire.update()\n')),(0,o.kt)("p",null,"Additionally, we need to update ",(0,o.kt)("inlineCode",{parentName:"p"},"drag()")," method to go through the draggable pile and update positions of all the cards being dragged: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def drag(self, e: ft.DragUpdateEvent):\n    draggable_pile = self.get_draggable_pile()\n    for card in draggable_pile:\n        card.top = max(0, self.top + e.delta_y) + draggable_pile.index(card) * CARD_OFFSET\n        card.left = max(0, self.left + e.delta_x)\n        card.update()\n")),(0,o.kt)("p",null,"Also, we need to update ",(0,o.kt)("inlineCode",{parentName:"p"},"place()")," method to place place the draggable pile to the slot:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def place(self, slot):\n    """Place draggable pile to the slot"""\n    draggable_pile = self.get_draggable_pile()\n\n    for card in draggable_pile:\n        card.top = slot.top + len(slot.pile) * CARD_OFFSET\n        card.left = slot.left\n\n        # remove card from it\'s original slot, if exists\n        if card.slot is not None:\n            card.slot.pile.remove(card)\n    \n        # change card\'s slot to a new slot\n        card.slot = slot\n\n        # add card to the new slot\'s pile\n        slot.pile.append(card)\n    \n    self.solitaire.update()\n')),(0,o.kt)("p",null,"Finally, if no slot in proximity is found, we need to bounce the whole pile back to its original position:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def bounce_back(self):\n    """Returns draggable pile to its original position"""\n    draggable_pile = self.get_draggable_pile()\n    for card in draggable_pile:\n        card.top = card.slot.top + card.slot.pile.index(card) * CARD_OFFSET\n        card.left = card.slot.left\n    self.solitaire.update()\n')),(0,o.kt)("p",null,"The full source code of this step can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/flet-dev/examples/tree/main/python/tutorials/solitaire/solitaire-fanned-piles"},"here"),". Now we can drag and drop cards in fanned piles, which means we are ready for the real deal! "),(0,o.kt)("h2",{id:"solitaire-setup"},"Solitaire setup"),(0,o.kt)("p",null,"Let\u2019s take a look at the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Klondike_(solitaire)#Rules"},"wikipedia article about Klondike (solitaire)"),":"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Klondike is played with a standard 52-card deck.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"After shuffling, a tableau of seven fanned piles of cards is laid from left to right. From left to right, each pile contains one more card than the last. The first and left-most pile contains a single upturned card, the second pile contains two cards, the third pile contains three cards, the fourth pile contains four cards, the fifth pile contains five cards, the sixth pile contains six cards, and the seventh pile contains seven cards. The topmost card of each pile is turned face up.\nThe remaining cards form the stock and are placed facedown at the upper left of the layout.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The four foundations (light rectangles in the upper right of the figure) are built up by suit from Ace (low in this game) to King, and the tableau piles can be built down by alternate colors.")),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/game_setup_wiki.png",className:"screenshot-40"}),(0,o.kt)("p",null,"We will now work on this setup step by step."),(0,o.kt)("h3",{id:"create-card-deck"},"Create card deck"),(0,o.kt)("p",null,"The first step is to create a full deck of cards in Solitaire class. Each card should have a ",(0,o.kt)("inlineCode",{parentName:"p"},"suit")," property (hearts, diamonds, clubs and spades) and a ",(0,o.kt)("inlineCode",{parentName:"p"},"rank")," property (from Ace to King).\nFor the suit, its ",(0,o.kt)("inlineCode",{parentName:"p"},"color")," is important, because tableau piles are built by alternate colors."),(0,o.kt)("p",null,"For the rank, its ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," is important, because foundations are built from the lowest (Ace) to the highest (King) rank value."),(0,o.kt)("p",null,"In solitaire.py, create ",(0,o.kt)("inlineCode",{parentName:"p"},"Suite")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Rank")," classes:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"class Suite:\n    def __init__(self, suite_name, suite_color):\n        self.name = suite_name\n        self.color = suite_color\n\nclass Rank:\n    def __init__(self, card_name, card_value):\n        self.name = card_name\n        self.value = card_value\n")),(0,o.kt)("p",null,"Now, in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Card")," class, instead of accepting the color as an argument, we\u2019ll be accepting ",(0,o.kt)("inlineCode",{parentName:"p"},"suite")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"rank")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"__init__()"),". Additionally, we\u2019ll add ",(0,o.kt)("inlineCode",{parentName:"p"},"face_up")," property to the card and the Container will now has image of the back of the card as its ",(0,o.kt)("inlineCode",{parentName:"p"},"content"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'class Card(ft.GestureDetector):\n    def __init__(self, solitaire, suite, rank):\n        super().__init__()\n        self.mouse_cursor=ft.MouseCursor.MOVE\n        self.drag_interval=5\n        self.on_pan_start=self.start_drag\n        self.on_pan_update=self.drag\n        self.on_pan_end=self.drop\n        self.suite=suite\n        self.rank=rank\n        self.face_up=False\n        self.top=None\n        self.left=None\n        self.solitaire = solitaire\n        self.slot = None\n        self.content=ft.Container(\n            width=CARD_WIDTH,\n            height=CARD_HEIGTH,\n            border_radius = ft.border_radius.all(6),\n            content=ft.Image(src="card_back.png"))\n')),(0,o.kt)("p",null,"All the images for the face up cards, as well as card back are stored in the \u201cimages\u201d folder in the same directory as main.py ","[link to github]",". "),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"For the reference to the image file to work, we need to specify the folder were it resides in the assets_dir in main.py:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-python"},'ft.app(target=main, assets_dir="images")\n'))),(0,o.kt)("p",null,"Finally, in ",(0,o.kt)("inlineCode",{parentName:"p"},"solitaire.create_card_deck()")," we'll create lists of suites and ranks and then the 52-card deck:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def create_card_deck(self):\n    suites = [\n        Suite("hearts", "RED"),\n        Suite("diamonds", "RED"),\n        Suite("clubs", "BLACK"),\n        Suite("spades", "BLACK"),\n    ]\n    ranks = [\n        Rank("Ace", 1),\n        Rank("2", 2),\n        Rank("3", 3),\n        Rank("4", 4),\n        Rank("5", 5),\n        Rank("6", 6),\n        Rank("7", 7),\n        Rank("8", 8),\n        Rank("9", 9),\n        Rank("10", 10),\n        Rank("Jack", 11),\n        Rank("Queen", 12),\n        Rank("King", 13),\n    ]\n\n    self.cards = []\n\n    for suite in suites:\n        for rank in ranks:\n            self.cards.append(Card(solitaire=self, suite=suite, rank=rank))\n')),(0,o.kt)("p",null,"The card deck is ready to be dealed, and now we need to create the layout for it."),(0,o.kt)("h3",{id:"create-slots"},"Create slots"),(0,o.kt)("p",null,"Klondike solitaire game layout should look like this:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/solitaire-layout.svg",className:"screenshot-80"}),(0,o.kt)("p",null,"Let\u2019s create all those slots in ",(0,o.kt)("inlineCode",{parentName:"p"},"solitaire.create_slots()"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def create_slots(self):\n    \n    self.stock = Slot(top=0, left=0, border=ft.border.all(1))\n    self.waste = Slot(top=0, left=100, border=None)\n\n    self.foundations = []\n    x = 300\n    for i in range(4):\n        self.foundations.append(Slot(top=0, left=x, border=ft.border.all(1, "outline")))\n        x += 100\n\n    self.tableau = []\n    x = 0\n    for i in range(7):\n        self.tableau.append(Slot(top=150, left=x, border=None))\n        x += 100\n\n    self.controls.append(self.stock)\n    self.controls.append(self.waste)\n    self.controls.extend(self.foundations)\n    self.controls.extend(self.tableau)\n    self.update()\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Note: some slots should have visible border and some shouldn\u2019t, so we added border to the list of arguments for the creation of ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," objects.")),(0,o.kt)("h3",{id:"deal-cards"},"Deal cards"),(0,o.kt)("p",null,"Let's start with shuffling the cards and adding them to the list of controls:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def deal_cards(self):\n    random.shuffle(self.cards)\n    self.controls.extend(self.cards)\n    self.update()\n")),(0,o.kt)("p",null,"Then we'll deal the cards to the tableau piles from left to right so that each pile contains one more card than the last, and place the remaining cards to the stock pile:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def deal_cards(self):\n    random.shuffle(self.cards)\n    self.controls.extend(self.cards)\n    \n    # deal to tableau\n    first_slot = 0\n    remaining_cards = self.cards\n    \n    while first_slot < len(self.tableau):\n        for slot in self.tableau[first_slot:]:\n            top_card = remaining_cards[0]\n            top_card.place(slot)\n            remaining_cards.remove(top_card)\n        first_slot +=1\n\n    # place remaining cards to stock pile\n    for card in remaining_cards:\n        card.place(self.stock)\n    \n    self.update()\n")),(0,o.kt)("p",null,"Let\u2019s run the program and see where we are at now:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/game_setup1.png",className:"screenshot-40"}),(0,o.kt)("p",null,"Cards in stock were placed in a fanned pile in the same manner as to the tableau, but they should have been placed to a regular pile instead. To fix this problem, let\u2019s add this condition to the ",(0,o.kt)("inlineCode",{parentName:"p"},"card.place()")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def place(self, slot):\n    """Place draggable pile to the slot"""\n    if slot in self.solitaire.tableau:\n        self.top = slot.top + len(slot.pile) * self.solitaire.card_offset\n    else:\n        self.top = slot.top\n    self.left = slot.left\n')),(0,o.kt)("p",null,"Now cards are only placed in fanned piles to tableau:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/game_setup2.png",className:"screenshot-40"}),(0,o.kt)("p",null,"If you try moving the cards around now, the program won\u2019t work. The reason for this is that in the ",(0,o.kt)("inlineCode",{parentName:"p"},"card.drop()")," method iterates through list of slots which we don\u2019t have now. "),(0,o.kt)("p",null,"Let\u2019s update the method to go separately through foundations and tableau:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def drop(self, e: ft.DragEndEvent):\n    for slot in self.solitaire.tableau:\n        if (\n            abs(self.top - (slot.top + len(slot.pile) * CARD_OFFSET)) < DROP_PROXIMITY\n        and abs(self.left - slot.left) < DROP_PROXIMITY\n        ):\n            self.place(slot)\n            self.update()\n            return\n\n    for slot in self.solitaire.foundations:\n        if (\n            abs(self.top - slot.top) < DROP_PROXIMITY\n        and abs(self.left - slot.left) < DROP_PROXIMITY\n        ):\n            self.place(slot)\n            self.update()\n            return\n        \n    self.bounce_back()\n    self.update()\n")),(0,o.kt)("h3",{id:"reveal-top-cards-in-tableau-piles"},"Reveal top cards in tableau piles"),(0,o.kt)("p",null,"Now we have the correct game setup and as a last touch we need to reveal the topmost cards in tableau piles."),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"Slot")," class, create a ",(0,o.kt)("inlineCode",{parentName:"p"},"get_top_card()")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def get_top_card(self):\n    if len(self.pile) > 0:\n        return self.pile[-1]\n")),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"Card")," class, create ",(0,o.kt)("inlineCode",{parentName:"p"},"turn_dace_up()")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def turn_face_up(self):\n    self.face_up = True\n    self.content.content.src=f"/images/{self.rank.name}_{self.suite.name}.svg"\n    self.update()\n')),(0,o.kt)("p",null,"Finally, reveal the topmost cards in the ",(0,o.kt)("inlineCode",{parentName:"p"},"solitaire.deal_cards()"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"for slot in self.tableau:\n    slot.get_top_card().turn_face_up()\n    self.update()\n")),(0,o.kt)("p",null,"Let\u2019s see how it looks now:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/game_setup3.png",className:"screenshot-50"}),(0,o.kt)("p",null,"The full source code for this step can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/flet-dev/examples/tree/main/python/tutorials/solitaire/solitaire-game-setup"},"here"),"."),(0,o.kt)("p",null,"Congratulations on completing the Solitaire game setup! You\u2019ve created a full 52-card deck, built layout with stock, waste, foundations and tableau piles, dealt the cards and revealed the top cards in tableau. Let\u2019s move on to the next item on our todo list, which is Solitaire Rules."),(0,o.kt)("h2",{id:"solitaire-rules"},"Solitaire rules"),(0,o.kt)("p",null,"If you run your current version of Solitaire, you\u2019ll notice that you can do some crazy things with your cards:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/game_rules1.gif",className:"screenshot-50"}),(0,o.kt)("p",null,"Now it is time to implement some rules."),(0,o.kt)("h3",{id:"general-rules"},"General rules"),(0,o.kt)("p",null,"Currently, we can move any card, but only face-up cards should be moved. Let\u2019s add this check in ",(0,o.kt)("inlineCode",{parentName:"p"},"start_drag"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"drag")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"drop")," methods of the card:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def start_drag(self, e: ft.DragStartEvent):\n    if self.face_up:\n        self.move_on_top()\n        self.update()\n\ndef drag(self, e: ft.DragUpdateEvent):\n    if self.face_up:\n        draggable_pile = self.get_draggable_pile()\n        for card in draggable_pile:\n            card.top = max(0, self.top + e.delta_y) + draggable_pile.index(card) * CARD_OFFSET\n            card.left = max(0, self.left + e.delta_x)\n            card.update()\n\ndef drop(self, e: ft.DragEndEvent):\n    if self.face_up:\n        for slot in self.solitaire.tableau:\n            if (\n                abs(self.top - (slot.top + len(slot.pile) * CARD_OFFSET)) < DROP_PROXIMITY\n            and abs(self.left - slot.left) < DROP_PROXIMITY\n        ):\n                self.place(slot)\n                self.update()\n                return\n        \n        for slot in self.solitaire.foundations:\n            if (\n                    abs(self.top - slot.top) < DROP_PROXIMITY\n            and abs(self.left - slot.left) < DROP_PROXIMITY\n        ):\n                self.place(slot)\n                self.update()\n                return\n        \n    self.bounce_back()\n    self.update()\n")),(0,o.kt)("p",null,"Now let\u2019s specify ",(0,o.kt)("inlineCode",{parentName:"p"},"click")," method for the ",(0,o.kt)("inlineCode",{parentName:"p"},"on_tap")," event of the card to reveal the card if you click on a faced-down top card in a tableau pile:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def click(self, e):\n    if self.slot in self.solitaire.tableau:\n        if not self.face_up and self == self.slot.get_top_card():\n            self.turn_face_up()\n            self.update()\n")),(0,o.kt)("p",null,"Let's check how it works:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/game_rules2.gif",className:"screenshot-50"}),(0,o.kt)("h3",{id:"foundations-rules"},"Foundations rules"),(0,o.kt)("p",null,"At the moment we can place fanned piles to foundations, which shouldn\u2019t be allowed. Let\u2019s check the draggable pile length to fix it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def drop(self, e: ft.DragEndEvent):\n    for slot in self.solitaire.tableau:\n        if (\n            abs(self.top - (slot.top + len(slot.pile) * CARD_OFFSET)) < DROP_PROXIMITY\n        and abs(self.left - slot.left) < DROP_PROXIMITY\n        ):\n            self.place(slot)\n            self.update()\n            return\n    \n    if len(self.get_draggable_pile()) == 1:\n        for slot in self.solitaire.foundations:\n            if (\n                abs(self.top - slot.top) < DROP_PROXIMITY\n        and abs(self.left - slot.left) < DROP_PROXIMITY\n        ):\n                self.place(slot)\n                self.update()\n                return\n        \n    self.bounce_back()\n    self.update()\n")),(0,o.kt)("p",null,"Then, of course, not any card can be placed to a foundation. According to the rules, a foundation should start with an Ace and then the cards of the same suite can be placed on top of it to build a pile form Ace to King."),(0,o.kt)("p",null,"Let\u2019s add this rule to Solitaire class:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def check_foundations_rules(self, card, slot):\n    top_card = slot.get_top_card()\n    if top_card is not None:\n        return (\n            card.suite.name == top_card.suite.name\n            and card.rank.value - top_card.rank.value == 1\n        )\n    else:\n        return card.rank.name == "Ace"\n')),(0,o.kt)("p",null,"We\u2019ll check this rule in ",(0,o.kt)("inlineCode",{parentName:"p"},"drop()")," method before placing a card to a foundation slot:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def drop(self, e: ft.DragEndEvent):\n    if self.face_up:\n        for slot in self.solitaire.tableau:\n            if (\n                abs(self.top - (slot.top + len(slot.pile) * CARD_OFFSET)) < DROP_PROXIMITY\n            and abs(self.left - slot.left) < DROP_PROXIMITY\n        ):\n                self.place(slot)\n                self.update()\n                return\n        \n        if len(self.get_draggable_pile()) == 1:\n            for slot in self.solitaire.foundations:\n                if (\n                    abs(self.top - slot.top) < DROP_PROXIMITY\n            and abs(self.left - slot.left) < DROP_PROXIMITY\n        ) and self.solitaire.check_foundations_rules(self, slot):\n                    self.place(slot)\n                    self.update()\n                    return\n        \n        self.bounce_back()\n        self.update()\n")),(0,o.kt)("p",null,"As a final touch for foundations rules, let\u2019s implement ",(0,o.kt)("inlineCode",{parentName:"p"},"doublclick")," method for ",(0,o.kt)("inlineCode",{parentName:"p"},"on_double_tap")," event of a card. It will be checking if the faced-up card fits into any of the foundations and place it there:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"   def doubleclick(self, e):\n       if self.face_up:\n           self.move_on_top()\n           for slot in self.solitaire.foundations:\n               if self.solitaire.check_foundations_rules(self, slot):\n                   self.place(slot)\n                   self.page.update()\n                   return\n")),(0,o.kt)("h3",{id:"tableau-rules"},"Tableau rules"),(0,o.kt)("p",null,"Finally, let's implement the rules to build tableau piles down from King to Ace by alternating suite color. Additionally, only King can be placed to an empty tableau slot."),(0,o.kt)("p",null,"Let\u2019s add these rules for Solitaire class:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def check_tableau_rules(self, card, slot):\n    top_card = slot.get_top_card()\n    if top_card is not None:\n        return (\n            card.suite.color != top_card.suite.color\n            and top_card.rank.value - card.rank.value == 1\n            and top_card.face_up\n        )\n    else:\n        return card.rank.name == "King"\n')),(0,o.kt)("p",null,"Similarly to the foundations rules, we\u2019ll check tableau rules before placing a card to a tableau pile:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def drop(self, e: ft.DragEndEvent):\n    if self.face_up:\n        for slot in self.solitaire.tableau:\n            if (\n                abs(self.top - (slot.top + len(slot.pile) * CARD_OFFSET)) < DROP_PROXIMITY\n            and abs(self.left - slot.left) < DROP_PROXIMITY\n        ) and self.solitaire.check_tableau_rules(self, slot):\n                self.place(slot)\n                self.update()\n                return\n        \n        if len(self.get_draggable_pile()) == 1:\n            for slot in self.solitaire.foundations:\n                if (\n                    abs(self.top - slot.top) < DROP_PROXIMITY\n            and abs(self.left - slot.left) < DROP_PROXIMITY\n        ) and self.solitaire.check_foundations_rules(self, slot):\n                    self.place(slot)\n                    self.update()\n                    return\n        \n        self.bounce_back()\n        self.update()\n")),(0,o.kt)("h3",{id:"stock-and-waste"},"Stock and waste"),(0,o.kt)("p",null,"To properly play Solitaire game right now we are missing the remaining cards that are piled in the stock."),(0,o.kt)("p",null,"Let\u2019s update ",(0,o.kt)("inlineCode",{parentName:"p"},"click()")," method of the card to go through the stock pile and place the cards to waste as we go:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def click(self, e):\n    if self.slot in self.solitaire.tableau:\n        if not self.face_up and self == self.slot.get_top_card():\n            self.turn_face_up()\n            self.update()\n    elif self.slot == self.solitaire.stock:\n        self.move_on_top()\n        self.place(self.solitaire.waste)\n        self.turn_face_up()\n        self.solitaire.update()\n")),(0,o.kt)("p",null,"That\u2019s it! Now you can properly play solitaire, but it very difficult to win the game if you cannot pass though the waste again. Let\u2019s implement ",(0,o.kt)("inlineCode",{parentName:"p"},"click()")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"on_click")," event of the stock Slot to go thought the stock pile again:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"class Slot(ft.Container):\n   def __init__(self, solitaire, top, left, border):\n       super().__init__()\n       self.pile=[]\n       self.width=SLOT_WIDTH\n       self.height=SLOT_HEIGHT\n       self.left=left\n       self.top=top\n       self.on_click=self.click\n       self.solitaire=solitaire\n       self.border=border\n       self.border_radius = ft.border_radius.all(6)\n  \n   def click(self, e):\n       if self == self.solitaire.stock:\n           self.solitaire.restart_stock()\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"restart_stock()")," method in ",(0,o.kt)("inlineCode",{parentName:"p"},"Solitaire")," class will place all cards from waste to stock again:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def restart_stock(self):\n    while len(self.waste.pile) > 0:\n        card = self.waste.get_top_card()\n        card.turn_face_down()\n        card.move_on_top()\n        card.place(self.stock)   \n    self.update\n")),(0,o.kt)("p",null,"For ",(0,o.kt)("inlineCode",{parentName:"p"},"card.place()")," method to work properly with cards from Stock and Waste, we\u2019ve added a condition to ",(0,o.kt)("inlineCode",{parentName:"p"},"card.get_draggable_pile()"),", so that it returns the top card only and not the whole pile:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def get_draggable_pile(self):\n    """returns list of cards that will be dragged together, starting with the current card"""\n    if self.slot is not None and self.slot != self.solitaire.stock and self.slot != self.solitaire.waste:\n        return self.slot.pile[self.slot.pile.index(self):]\n    return [self]\n')),(0,o.kt)("p",null,"All done! The full source code for this step can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/flet-dev/examples/tree/main/python/tutorials/solitaire/solitaire-game-rules"},"here"),"."),(0,o.kt)("p",null,"Let\u2019s move on to the last step of the game itself - detecting the situation when you have won."),(0,o.kt)("h2",{id:"winning-the-game"},"Winning the game"),(0,o.kt)("p",null,"According to ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Klondike_(solitaire)#Probability_of_winning"},"wikipedia"),", some suggest the chances of winning the game as being 1 in 30 games. "),(0,o.kt)("p",null,"Knowing that the chances of winning are quite low, we should plan on showing the user something exciting when that finally happens."),(0,o.kt)("p",null,"First, let\u2019s add a check for the winning condition to ",(0,o.kt)("inlineCode",{parentName:"p"},"Solitaire")," class. If all four foundations contain total of 52 cards, then you have won:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def check_win(self):\n    cards_num = 0\n    for slot in self.foundations:\n        cards_num += len(slot.pile)\n    if cards_num == 52:\n        return True\n    return False\n")),(0,o.kt)("p",null,"We\u2019ll be checking if this condition is true each time a card is placed to a foundation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def place(self, slot):\n    """Place draggable pile to the slot"""\n    \n    draggable_pile = self.get_draggable_pile()\n\n    for card in draggable_pile:\n        if slot in self.solitaire.tableau:\n            card.top = slot.top + len(slot.pile) * CARD_OFFSET\n        else:\n            card.top = slot.top\n        card.left = slot.left\n\n        # remove card from it\'s original slot, if exists\n        if card.slot is not None:\n            card.slot.pile.remove(card)\n    \n        # change card\'s slot to a new slot\n        card.slot = slot\n\n        # add card to the new slot\'s pile\n        slot.pile.append(card)\n    \n    if self.solitaire.check_win():\n        self.solitaire.winning_sequence()\n    \n    self.solitaire.update()\n')),(0,o.kt)("p",null,"Finally, if the winning condition is met, it will trigger a winning sequence involving ",(0,o.kt)("a",{parentName:"p",href:"https://flet.dev/docs/guides/python/animations#position-animation"},"position animation"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def winning_sequence(self):\n    for slot in self.foundations:   \n        for card in slot.pile:\n            card.animate_position=1000\n            card.move_on_top()\n            card.top = random.randint(0, SOLITAIRE_HEIGHT)\n            card.left = random.randint(0, SOLITAIRE_WIDTH)\n            self.update()\n    self.controls.append(ft.AlertDialog(title=ft.Text("Congratulations! You won!"), open=True))\n')),(0,o.kt)("p",null,"As you can imagine, it took me a while before I could win the game and take this video, but here it is:"),(0,o.kt)("img",{src:"/img/docs/solitaire-tutorial/winning_the_game.gif",className:"screenshot-50"}),(0,o.kt)("p",null,"Wow! We did it. You can find the full source code for the Part 1 of the Solitaire game ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/flet-dev/examples/tree/main/python/tutorials/solitaire/solitaire-final-part1"},"here"),". "),(0,o.kt)("p",null,"In Part 2 we will be adding top menu with options to restart the game, view game rules and change game settings such as waste size, number of passes through the waste and card back image."),(0,o.kt)("p",null,"Now, as we have a decent desktop version of the game, let\u2019s deploy it as a web app to share with your friends and colleagues."),(0,o.kt)("h2",{id:"deploying-the-app"},"Deploying the app"),(0,o.kt)("p",null,"Congratulations! You have created your Solitaire game app in Python with Flet, and it looks awesome!"),(0,o.kt)("p",null,"Now it's time to share your app with the world!"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/docs/guides/python/deploying-web-app"},"Follow these instructions")," to deploy your Flet app as a web app to Fly.io or Replit."),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"In this tutorial, you have learnt how to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Create a simple Flet app;"),(0,o.kt)("li",{parentName:"ul"},"Drag and drop cards with GestureDetector;"),(0,o.kt)("li",{parentName:"ul"},"Create your own classes that inherit from Flet controls;"),(0,o.kt)("li",{parentName:"ul"},"Design UI layout using absolute positioning of controls in Stack;"),(0,o.kt)("li",{parentName:"ul"},"Implement implicit animations;"),(0,o.kt)("li",{parentName:"ul"},"Deploy your Flet app to the web;")),(0,o.kt)("p",null,"For further reading you can explore ",(0,o.kt)("a",{parentName:"p",href:"/docs/controls"},"controls")," and ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/flet-dev/examples/tree/main/python"},"examples repository"),"."),(0,o.kt)("p",null,"We would love to hear your feedback! Please drop us an ",(0,o.kt)("a",{parentName:"p",href:"mailto:hello@flet.dev"},"email"),", join the discussion on ",(0,o.kt)("a",{parentName:"p",href:"https://discord.gg/dzWXP8SHG8"},"Discord"),", follow on ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/fletdev"},"Twitter"),"."))}u.isMDXComponent=!0}}]);